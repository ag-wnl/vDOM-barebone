{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Block, Edit, Props, VElement, VNode } from \"./types\";\n\n/**\n * @reference https://github.com/aidenybai/hundred#readme\n */\n\n// Helper function to create virtual dom nodes\n// e.g. h('div', { id: 'foo' }, 'hello') => <div id=\"foo\">hello</div>\nexport const h = (\n  type: string,\n  props: Props = {},\n  ...children: VNode[]\n): VElement => ({\n  type,\n  props,\n  children,\n});\n\n// console.log(h(\"div\", { id: \"foo\" }, \"hello\"));\n// gives us { type: 'div', props: { id: 'foo' }, children: ['hello'] }\n\n// console.log(h(\"div\", { id: \"foo\" }, h(\"span\", {}, \"hello\")));\n// gives us { type: 'div', props: { id: 'foo' }, children: [{ type: 'span', props: null, children: ['hello'] }] }\n\n/**\n * @description Hole is a placeholder for a value that will be filled in later\n * helps in static analysis as we can just assign a value to a hole - essentially making it reactive\n *\n * @param key: propety name that was accessed (captured by our Proxy interceptor)\n */\nclass Hole {\n  key: string;\n  constructor(key: string) {\n    this.key = key;\n  }\n}\n\n/**\n * @description helps create a mapping between props and virtual nodes. This is done by the\n * Proxy - which we use to intercept any property access and create our mapping\n *\n * We track which properties are accessed and create a mapping between the property name and the hole\n *\n * @param fn : (props: Props) => VNode. User provides a func which takes props\n * @returns generated virtual dom node, based on the props\n */\nexport const block = (fn: (props: Props) => VNode) => {\n  const proxy = new Proxy(\n    {},\n    {\n      // we intercept any prop access, and return the hole value instead\n      get(_, prop: string) {\n        return new Hole(prop);\n      },\n    }\n  );\n\n  // function call with proxy as the prop (so our interception can work):\n  const vnode = fn(proxy);\n\n  // edits is a mutable array, so we pass it by reference\n  const edits: Edit[] = [];\n  // by rendering the vnode, we also populate the edits array\n  // by parsing the vnode for Hole placeholders\n  const root = render(vnode, edits);\n\n  // factory function to create instances of this block\n  return (props: Props): Block => {\n    // elements stores the element references for each edit\n    // during mount, which can be used during patch later\n    const elements = new Array(edits.length);\n\n    // mount puts the element for the block on some parent element\n    const mount = (parent: HTMLElement) => {\n      // cloneNode saves memory by not reconstrcuting the dom tree\n      const el = root.cloneNode(true);\n      // we assume our rendering scope is just one block\n      parent.textContent = \"\";\n      parent.appendChild(el);\n\n      for (let i = 0; i < edits.length; i++) {\n        const edit = edits[i];\n        // walk the tree to find the element / hole\n        let thisEl = el;\n        // If path = [1, 2, 3]\n        // thisEl = el.childNodes[1].childNodes[2].childNodes[3]\n        for (let i = 0; i < edit.path.length; i++) {\n          thisEl = thisEl.childNodes[edit.path[i]];\n        }\n\n        // make sure we save the element reference\n        elements[i] = thisEl;\n\n        // this time, we can get the value from props\n        const value = props[edit.hole];\n\n        if (edit.type === \"attribute\") {\n          // @ts-ignore\n          thisEl[edit.attribute] = value;\n        } else if (edit.type === \"child\") {\n          // handle nested blocks if the value is a block\n          if (value.mount && typeof value.mount === \"function\") {\n            value.mount(thisEl);\n            continue;\n          }\n\n          const textNode = document.createTextNode(value);\n          thisEl.insertBefore(textNode, thisEl.childNodes[edit.index]);\n        }\n      }\n    };\n\n    // patch updates the element references with new values\n    const patch = (newBlock: Block) => {\n      for (let i = 0; i < edits.length; i++) {\n        const edit = edits[i];\n        const value = props[edit.hole];\n        const newValue = newBlock.props[edit.hole];\n\n        // dirty check\n        if (value === newValue) continue;\n\n        const thisEl = elements[i];\n\n        if (edit.type === \"attribute\") {\n          thisEl[edit.attribute] = newValue;\n        } else if (edit.type === \"child\") {\n          // handle nested blocks if the value is a block\n          if (value.patch && typeof value.patch === \"function\") {\n            // patch cooresponding child blocks\n            value.patch(newBlock.edits[i].hole);\n            continue;\n          }\n          thisEl.childNodes[edit.index].textContent = newValue;\n        }\n      }\n    };\n\n    return { mount, patch, props, edits };\n  };\n};\n\n/**\n * @description renders the virtual dom node to the DOM\n * If the node has children, we recursively render each child (dfs into the tree)\n *\n * We also do static analysis in order to determine where edits are\n * required to be made\n *\n * @param vnode : virtual dom node\n * @param edits : list of edits to be made to the dom. Edit represents a mapping between a hole and the value\n * each Edit has data where the relevant DOM node is in the tree, key to access the props via hole\n * and property name we wan to update (via name if it's an attribute, or index if it's a child)\n *\n * @returns HTMLElement | Text\n */\nexport const render = (\n  // represents a virtual dom node, built w/ `h` function\n  vnode: VNode,\n  // represents a list of edits to be made to the dom,\n  // processed by identifying `Hole` placeholder values\n  // in attributes and children.\n  //    NOTE: this is a mutable array, and we assume the user\n  //    passes in an empty array and uses that as a reference\n  //    for the edits.\n  edits: Edit[] = [],\n  // Path is used to keep track of where we are in the tree\n  // as we traverse it.\n  // e.g. [0, 1, 2] would mean:\n  //    el1 = 1st child of el\n  //    el2 = 2nd child of el1\n  //    el3 = 3rd child of el2\n  path: number[] = []\n): HTMLElement | Text => {\n  if (typeof vnode === \"string\") return document.createTextNode(vnode);\n\n  const el = document.createElement(vnode.type);\n\n  if (vnode.props) {\n    for (const name in vnode.props) {\n      const value = vnode.props[name];\n      if (value instanceof Hole) {\n        edits.push({\n          type: \"attribute\",\n          path, // the path we need to traverse to get to the element\n          attribute: name, // to set the value during mount/patch\n          hole: value.key, // to get the value from props during mount/patch\n        });\n        continue;\n      }\n      // @ts-ignore\n      el[name] = value;\n    }\n  }\n\n  for (let i = 0; i < vnode.children?.length; i++) {\n    const child = vnode.children[i];\n    if (child instanceof Hole) {\n      edits.push({\n        type: \"child\",\n        path, // the path we need to traverse to get to the parent element\n        index: i, // index represents the position of the child in the parent used to insert/update the child during mount/patch\n        hole: child.key, // to get the value from props during mount/patch\n      });\n      continue;\n    }\n    // we respread the path to avoid mutating the original array\n    el.appendChild(render(child, edits, [...path, i]));\n  }\n\n  return el;\n};\n"],"mappings":"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","names":["index_exports","__export","block","h","render","__toCommonJS","type","props","children","Hole","key","fn","proxy","_","prop","vnode","edits","root","elements","parent","el","i","edit","thisEl","value","textNode","newBlock","newValue","path","name","child"]}