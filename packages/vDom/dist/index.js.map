{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Block, Edit, Props, VElement, VNode } from \"./types\";\n\n/**\n * @reference https://github.com/aidenybai/hundred#readme\n */\n\n// Helper function to create virtual dom nodes\n// e.g. h('div', { id: 'foo' }, 'hello') => <div id=\"foo\">hello</div>\n\n// console.log(h(\"div\", { id: \"foo\" }, \"hello\"));\n// gives us { type: 'div', props: { id: 'foo' }, children: ['hello'] }\n\n// console.log(h(\"div\", { id: \"foo\" }, h(\"span\", {}, \"hello\")));\n// gives us { type: 'div', props: { id: 'foo' }, children: [{ type: 'span', props: null, children: ['hello'] }] }\nexport const h = (\n  type: string,\n  props: Props = {},\n  ...children: VNode[]\n): VElement => ({\n  type,\n  props,\n  children,\n});\n\n/**\n * @description Hole is a placeholder for a value that will be filled in later\n * helps in static analysis as we can just assign a value to a hole - essentially making it reactive\n *\n * @param key: propety name that was accessed (captured by our Proxy interceptor)\n */\nclass Hole {\n  key: string;\n  constructor(key: string) {\n    this.key = key;\n  }\n}\n\n/**\n * @description helps create a mapping between props and virtual nodes. This is done by the\n * Proxy - which we use to intercept any property access and create our mapping\n *\n * We track which properties are accessed and create a mapping between the property name and the hole\n *\n * @param fn : (props: Props) => VNode. User provides a func which takes props\n * @returns generated virtual dom node, based on the props\n */\nexport const block = (fn: (props: Props) => VNode) => {\n  const proxy = new Proxy(\n    {},\n    {\n      // we intercept any prop access, and return the hole value instead\n      get(_, prop: string) {\n        return new Hole(prop);\n      },\n    }\n  );\n\n  // function call with proxy as the prop (so our interception can work):\n  const vnode = fn(proxy);\n\n  // edits is a mutable array, so we pass it by reference\n  const edits: Edit[] = [];\n  // by rendering the vnode, we also populate the edits array\n  const root = render(vnode, edits);\n\n  // factory function to create instances of this block\n  return (props: Props): Block => {\n    // elements stores the element references for each edit\n    // during mount, which can be used during patch later\n    const elements = new Array(edits.length);\n    const eventListeners = new Map<string, Function>();\n\n    // mount puts the element for the block on some parent element\n    const mount = (parent: HTMLElement) => {\n      // cloneNode saves memory by not reconstrcuting the dom tree\n      const el = root.cloneNode(true);\n      // we assume our rendering scope is just one block\n      parent.textContent = \"\";\n      parent.appendChild(el);\n\n      for (let i = 0; i < edits.length; i++) {\n        const edit = edits[i];\n\n        /**\n         * Now we will be walking the tree to find the element / hole\n         * Ex: If path = [1, 2, 3]\n         * thisEl = el.childNodes[1].childNodes[2].childNodes[3]\n         *\n         * We start with thisEl = el, as the element is the root parent and\n         * then we walk the tree using the path to reach the element\n         */\n        let thisEl = el;\n        for (let i = 0; i < edit.path.length; i++) {\n          thisEl = thisEl.childNodes[edit.path[i]];\n        }\n\n        // make sure we save the element reference\n        elements[i] = thisEl;\n\n        // this time, we can get the value from props\n        const value = props[edit.hole];\n\n        if (edit.type === \"attribute\") {\n          if (edit.attribute.startsWith(\"on\")) {\n            const eventName = edit.attribute.slice(2).toLowerCase();\n            const handler =\n              typeof value === \"function\" ? value : (props[value] as Function);\n\n            if (handler) {\n              thisEl.addEventListener(eventName, handler);\n              eventListeners.set(eventName, handler);\n            }\n          } else {\n            // @ts-ignore\n            thisEl[edit.attribute] = value;\n          }\n        } else if (edit.type === \"child\") {\n          // if the value is a block, mount it (this means we have a nested block)\n          if (value.mount && typeof value.mount === \"function\") {\n            value.mount(thisEl);\n          } else {\n            // else insert a text node at the specified index\n            const textNode = document.createTextNode(value);\n            thisEl.insertBefore(textNode, thisEl.childNodes[edit.index]);\n          }\n        }\n      }\n    };\n\n    const patch = (newBlock: Block) => {\n      for (let i = 0; i < edits.length; i++) {\n        const edit = edits[i];\n\n        const currentValue = props[edit.hole];\n        const newValue = newBlock.props[edit.hole];\n\n        if (currentValue === newValue) continue;\n\n        const thisEl = elements[i];\n\n        if (edit.type === \"attribute\") {\n          if (edit.attribute.startsWith(\"on\")) {\n            const eventName = edit.attribute.slice(2).toLowerCase();\n\n            const oldHandler = eventListeners.get(eventName);\n            const newHandler =\n              typeof newValue === \"function\"\n                ? newValue\n                : (newBlock.props[newValue] as Function);\n\n            if (oldHandler) {\n              thisEl.removeEventListener(eventName, oldHandler);\n              eventListeners.delete(eventName);\n            }\n\n            if (newHandler) {\n              thisEl.addEventListener(eventName, newHandler);\n              eventListeners.set(eventName, newHandler);\n            }\n          } else {\n            thisEl[edit.attribute] = newValue;\n          }\n        } else if (edit.type === \"child\") {\n          if (\n            currentValue &&\n            typeof currentValue === \"object\" &&\n            currentValue.patch\n          ) {\n            currentValue.patch(newBlock.edits[i].hole);\n          } else {\n            thisEl.childNodes[edit.index].textContent = String(newValue);\n          }\n        }\n      }\n    };\n\n    return { mount, patch, props, edits };\n  };\n};\n\n/**\n * @description renders the virtual dom node to the DOM\n * If the node has children, we recursively render each child (dfs into the tree)\n *\n * We also do static analysis in order to determine where edits are\n * required to be made\n *\n * @param vnode : virtual dom node\n * @param edits : list of edits to be made to the dom. Edit represents a mapping between a hole and the value\n * each Edit has data where the relevant DOM node is in the tree, key to access the props via hole\n * and property name we wan to update (via name if it's an attribute, or index if it's a child)\n *  \n * Ex of edits:\n * [\n  {\n    type: 'attribute',\n    path: [0, 1], // Path to the element\n    attribute: 'class', // Attribute to update\n    hole: 'className', // Key to look up the value in props\n  },\n  {\n    type: 'child',\n    path: [0], // Path to the parent element\n    index: 2, // Position of the child in the parent\n    hole: 'text', // Key to look up the value in props\n  },\n  ]\n *\n * @returns HTMLElement | Text\n */\nexport const render = (\n  // represents a virtual dom node, built w/ `h` function\n  vnode: VNode,\n  // represents a list of edits to be made to the dom,\n  // processed by identifying `Hole` placeholder values\n  // in attributes and children.\n  //    NOTE: this is a mutable array, and we assume the user\n  //    passes in an empty array and uses that as a reference\n  //    for the edits.\n  edits: Edit[] = [],\n  /**\n   * Path is used to keep track of where we are in the tree.\n   * An array of indices that represents the position of an element in the DOM tree.\n   *\n   * For example, [0, 1, 2] means:\n   * - Start at the root element\n   * - Go to the 1st child (index 0)\n   * - Go to the 2nd child of that child (index 1)\n   * - Go to the 3rd child of that child (index 2)\n   *\n   * e.g. [0, 1, 2] would mean:\n   *    el1 = 1st child of el\n   *    el2 = 2nd child of el1\n   *    el3 = 3rd child of el2\n   */\n  path: number[] = []\n): HTMLElement | Text => {\n  if (typeof vnode === \"string\") return document.createTextNode(vnode);\n\n  const el = document.createElement(vnode.type);\n\n  if (vnode.props) {\n    for (const name in vnode.props) {\n      const value = vnode.props[name];\n\n      // handle event listeners\n      // handle event listeners differently\n      if (name.startsWith(\"on\")) {\n        if (value instanceof Hole) {\n          edits.push({\n            type: \"attribute\",\n            path,\n            attribute: name,\n            hole: value.key,\n          });\n        } else if (typeof value === \"function\") {\n          // Preserve function reference in edits\n          edits.push({\n            type: \"attribute\",\n            path,\n            attribute: name,\n            hole: value,\n          });\n\n          const eventName = name.slice(2).toLowerCase();\n          el.addEventListener(eventName, value);\n        }\n        continue;\n      }\n\n      if (value instanceof Hole) {\n        edits.push({\n          type: \"attribute\",\n          path, // path to the element\n          attribute: name, // attribute to update during mount/patch\n          hole: value.key, // key to look up the value in props during mount/patch\n        });\n      } else {\n        // @ts-ignore\n        el[name] = value; // set the attribute directly if it's not a Hole\n      }\n    }\n  }\n\n  for (let i = 0; i < vnode.children?.length; i++) {\n    const child = vnode.children[i];\n    if (child instanceof Hole) {\n      // mark the child as a hole so in future we can dynamically insert/update the child\n      edits.push({\n        type: \"child\",\n        path, // path to the parent element\n        index: i, // index represents the position of the child in the parent. Used to insert/update the child during mount/patch\n        hole: child.key, // key to look up the value in props during mount/patch\n      });\n    } else {\n      // we respread the path to avoid mutating the original array\n      el.appendChild(render(child, edits, [...path, i]));\n    }\n  }\n\n  return el;\n};\n"],"mappings":"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","names":["index_exports","__export","block","h","render","__toCommonJS","type","props","children","Hole","key","fn","proxy","_","prop","vnode","edits","root","elements","eventListeners","parent","el","i","edit","thisEl","value","eventName","handler","textNode","newBlock","currentValue","newValue","oldHandler","newHandler","path","name","child"]}